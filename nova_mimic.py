#!/usr/bin/python
# -*- coding: utf-8 -*-

import os
import os.path

from ConfigParser import ConfigParser

import libvirt
import pymongo
import gridfs
from bson.objectid import ObjectId
import xml.etree.ElementTree as ElementTree

from src.database_toolkit import (
    Flavor, Image, MacAddress,
    Instance, contexted_session
)

from utils.caas import conf

PATH_TO_GLOBAL_CONFIG = './conf.ini'


class NovaMimic:
    #dictionary where key - domain name and value - domain object
    #main purpose - providing quick access to domain object
    domains_pool = {}

    #states of domain is mapped on global variables from
    #libvirt module. Following dict is defined for the sake
    #of convinience
    domain_state = {
        1: "running",
        3: "suspended",
        5: "shut off"
    }

    #TODO: think about correct way to close connection
    def __init__(self):
        self.libvirt_connection = libvirt.open('qemu:///system')

        conf = ConfigParser()
        conf.read(PATH_TO_GLOBAL_CONFIG)
        self.path_to_xml_config_pattern = conf.get(
            'xml_config',
            'path_to_xml_pattern_conf'
        )

        self.path_to_image_storage = conf.get(
            'image_storage',
            'path_to_image_storage'
        )

    def instance_boot(self, instance_name, image_id, flavor_id):
        '''
        Function boots instance with given name, image id and flavor id.

        Image id is used to fetch informtion about image which will be
        using for booting up VM instance. Image information include:
        metadata on image (name, format, size)
        and key for retrieving image itself from key-value storage.

        Flavor id is used to fetch information about virtual hardware
        (amount of RAM and virtual CPU) that will be provisioned to VM
        instance by building xml configuration file for libvirt.

        Returns: information about booted instance
            - id (uuid generated by libvirt driver for instance)
        '''
        # get flavor data from database
        with contexted_session() as s:
            flavor = s.query(Flavor).filter(Flavor.id == flavor_id).one()
            image = s.query(Image).filter(Image.id == image_id).one()
            # first free mac address
            mac_address = s.query(MacAddress)\
                           .filter(MacAddress.is_free == True)\
                           .first()

            xml_config_string = self._xml_processing(
                instance_name,
                image.id,
                flavor.memory,
                flavor.vcpu,
                mac_address.address
            )

            self._image_processing(image.id)

            #start domain from xml_configuration_string
            #and update pool of domains
            domain = self.libvirt_connection.createXML(
                xml_config_string,
                0
            )

            self.domains_pool.update(
                {
                    instance_name: domain
                }
            )

            #updating needed tables in data base
            #save information about instance i.e. domain id,
            #domain name, state and mac address
            instance = Instance(
                domain_id=domain.UUIDString(),
                name=instance_name,
                state=domain.state(0)[0],
                mac_addr=mac_address.id
            )
            s.add(instance)

            #update mac_address row
            mac_address.is_free = False

    def _xml_processing(self, instance_name, image_id, memory, vcpu, mac_address):
        # parse pattern xml config and update needed sections in order to make
        # own config
        instance_config = ElementTree.parse(self.path_to_xml_config_pattern)
        doc_root = instance_config.getroot()

        # updating name of instance
        name = doc_root.find('name')
        name.text = instance_name

        # amount of memory that will be available to instance
        doc_root.find('memory').text = str(memory)

        # amount of currentMemory is equal to total memory for this
        # instance
        doc_root.find('currentMemory').text = str(memory)

        # vcpu
        doc_root.find('vcpu').text = str(vcpu)

        # path to image which will be used for booting
        devices = doc_root.find('devices')

        for disk in devices.findall('disk'):
            if disk.get('type') == 'file':
                disk.find('source').set(
                    'file',
                    os.path.join(
                        self.path_to_image_storage,
                        image_id
                    )
                )

        # mac address for this instance
        for interface in devices.findall('interface'):
            if interface.get('type') == 'network':
                interface.find('mac').set('address', mac_address)

        return ElementTree.tostring(doc_root)

    def _image_processing(self, image_id):
        '''
        Performs serch of image in local image storage directory
        with image_id param value name. If there exsists
        such file - do nothing, in other case - download
        image from key-value storage.
        '''
        path_to_image = os.path.join(self.path_to_image_storage, image_id)

        if not os.path.exists(path_to_image):
            with pymongo.MongoClient() as client:
                storage = client.image_storage
                grfs = gridfs.GridFS(storage)

                with open(path_to_image, 'wb') as f:
                    grout = grfs.get(ObjectId(image_id))
                    f.write(grout.read())

    def instance_reboot(self, instance_id):
        pass

    def instance_shutdown(self, instance_id):
        pass

    def instance_destroy(self, instance_id):
        pass

    def image_list(self):
        pass

    def flavor_list(self):
        pass
