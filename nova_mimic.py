#!/usr/bin/python
# -*- coding: utf-8 -*-

import os
import os.path

import libvirt
import pymongo
import gridfs
from bson.objectid import ObjectId
import xml.etree.ElementTree as ElementTree

from src.database_toolkit import Flavor, Image, MacAddress, Instance, contexted_session

# in future these next flobals may be moved to config file
PROJECTS_PATH = '/home/aroma/Programming/sandbox/test/data/'
XML_PATTERN_FOR_INSTANCE = '/home/aroma/Programming/sandbox/test/data/domain_pattern.xml'


class NovaMimic:
    #dictionary where key - domain name and value - domain object
    #main purpose - providing quick access to domain object
    domains_pool = {}

    #states of domain is mapped on global variables from
    #libvirt module. Following dict is defined for the sake
    #of convinience
    domain_state = {
        1: "running",
        3: "suspended",
        5: "shut off"
    }


    #TODO: think about correct way to close connection
    def __init__(self):
        self.libvirt_connection = libvirt.open('qemu:///system')

    def instance_boot(self, instance_name, image_id, flavor_id):
        '''
        Function boots instance with given name, image id and flavor id.

        Image id is used to fetch informtion about image which will be using for
        booting up VM instance. Image information include: metadata on image (name, format, size)
        and key for retrieving image itself from key-value storage.

        Flavor id is used to fetch information about virtual hardware (amount of RAM and virtual CPU)
        that will be provisioned to VM instance by building xml configuration file for libvirt.

        Returns: information about booted instance
            - id (uuid generated by libvirt driver for instance)
        '''
        self._manage_project_path(instance_name)

        # get flavor data from database
        with contexted_session() as s:
            flavor = s.query(Flavor).filter(Flavor.id == flavor_id).one()
            image = s.query(Image).filter(Image.id == image_id).one()
            # first free mac address
            mac_address = s.query(MacAddress).filter(MacAddress.is_free == True).first()

            path_to_xml_config = self._xml_processing(
                instance_name,
                image.name,
                flavor.memory,
                flavor.vcpu,
                mac_address.address
            )

            self._image_processing(image.name, image.storage_key)

            #supply xml to libvirt for defining. After this
            #domain should be available for managing via libvirt driver
            self.libvirt_connection.defineXML(path_to_xml_config)

            #get domain object to operate on and put it in
            #domains pool for furhter usage
            if instance_name in self.libvirt_connection.listDefinedDomains():
                domain = self.libvirt_connection.lookupByName(instance_name)
                domain.create()

                self.domains_pool.update(
                    {
                        instance_name: domain
                    }
                )

            #updating needed tables in data base
            #save information about instance i.e. domain id,
            #domain name, state and mac address
            instance = Instance(
                domain_id=domain.UUIDString(),
                name=instance_name,
                state=domain.state(0)[0],
                mac_addr=mac_address.id
            )
            s.add(instance)

            #update mac_address row
            mac_address.is_free = False

    def _manage_project_path(self, instance_name):
        # create directory for instance project (include xml file for libvirt
        # and image for booting). Save produced path as class atribute
        self.current_project_path = os.path.join(PROJECTS_PATH, instance_name)
        if not os.path.exists(self.current_project_path):
            os.mkdir(self.current_project_path)

    def _xml_processing(self, instance_name, image_name, memory, vcpu, mac_address):
        # parse pattern xml config and update needed sections in order to make
        # own config
        instance_config = ElementTree.parse(XML_PATTERN_FOR_INSTANCE)
        doc_root = instance_config.getroot()

        # updating name of instance
        name = doc_root.find('name')
        name.text = instance_name

        # amount of memory that will be available to instance
        doc_root.find('memory').text = str(memory)

        # amount of currentMemory is equal to total memory for this
        # instance
        doc_root.find('currentMemory').text = str(memory)

        # vcpu
        doc_root.find('vcpu').text = str(vcpu)

        # path to image which will be used for booting
        devices = doc_root.find('devices')

        for disk in devices.findall('disk'):
            if disk.get('type') == 'file':
                disk.find('source').set(
                    'file',
                    os.path.join(
                        self.current_project_path,
                        '{0}.img'.format(image_name)
                    )
                )

        # mac address for this instance
        for interface in devices.findall('interface'):
            if interface.get('type') == 'network':
                interface.find('mac').set('address', mac_address)

        # write config
        path_to_xml_config = os.path.join(
            self.current_project_path,
            '{0}.xml'.format(instance_name)
        )

        instance_config.write(path_to_xml_config)

        return path_to_xml_config

    def _image_processing(self, image_name, storage_key):
        # get connection with mongoDB via creating client and download image
        # using gridfs module
        with pymongo.MongoClient() as client:
            storage = client.image_storage
            grfs = gridfs.GridFS(storage)

            with open(os.path.join(self.current_project_path, '{0}.img'.format(image_name)), 'wb') as f:
                grout = grfs.get(ObjectId(storage_key))
                f.write(grout.read())

    def instance_reboot(self, instance_id):
        pass

    def instance_shutdown(self, instance_id):
        pass

    def instance_destroy(self, instance_id):
        pass

    def image_list(self):
        pass

    def flavor_list(self):
        pass
